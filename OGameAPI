#Downloaded Libraries
import mechanize

#Built in Libraries
from math import pow
import re

class _Entity: #This is the base class for all research, resource, and facility objects
	
	#Note to self: Modifiers should be for, Cost Increase Factor, Shipyard, Robotics Factory and Nanite Factory
	def __init__(self, browser, modifiers, base_costs, id, link):
		self.level = update_level(browser)
		self.id = id
		self.link = link
		
		self.base_cost_metal = base_costs[0]
		self.base_cost_crystal = base_costs[1]
		self.base_cost_deuterium = base_costs[2]
		self.cost_increase_factor = modifiers[0]
		
		self.metal_upgrade_cost = _calculate_build_cost(self.base_cost_metal, self.cost_increase_factor)
		self.crystal_upgrade_cost = _calculate_build_cost(self.base_cost_crystal, self.cost_increase_factor)
		self.deuterium_upgrade_cost = _calculate_build_cost(self.base_cost_crystal, self.cost_increase_factor)
		
	def _calculate_build_cost(self, base_cost, cost_increase_factor):
		return int(base_cost * pow(1- cost_increase_factor, self.level - 1))
	
	def _update_costs(self, browser):
		self.update_level(browser, self.id, self.link)
		self.metal_upgrade_cost = _calculate_build_cost(self.base_cost_metal, self.cost_increase_factor)
		self.crystal_upgrade_cost = _calculate_build_cost(self.base_cost_crystal, self.cost_increase_factor)
		self.deuterium_upgrade_cost = _calculate_build_cost(self.base_cost_crystal, self.cost_increase_factor)
	
	def _update_level(self, browser):
		if self.link not in browser.getlink(): #I.e. the browser is not where I want it at the moment.
			html = browser.open(self.link)
			
		html_crawler = BeautifulSoup(html.read())
		html_level_string = str(html_crawler.find('li',{'id': id }))
		self.level = int(re.search('\d', html_level_string)) #Using regular expressions, I can strip out the solitary level decimal
	
	def build(self, browser):
		html_crawler = BeautifulSoup(html.read())
		html_level_string = str(html_crawler.find('li',{'id':self.id}))
		upgrade_link = re.search('Request\(\'(.+?)\',',html_level_string).group(1).replace("amp;","")
			
		if upgrade_link:
			html = browser.open(upgrade_link)
			html_crawler = BeautifulSoup(html.read())
			html_level_string = str(html_crawler.find('li',{'id':self.id}))
			upgrade_link = re.search('Request\(\'(.+?)\',',html_level_string).group(1).replace("amp;","")
			if not upgrade_link:
				return self._buildtime()

		return 0
		
	def buildable(self, browser):
		self._update_costs(browser)
		
		html_crawler = BeautifulSoup(html.read())
		html_level_string = str(html_crawler.find('span',{'id':'resources_metal'}))
		metal_available = int(re.search('\d', html_level_string))
		
		html_level_string = str(html_crawler.find('span',{'id':'resources_crystal'}))
		crystal_available = int(re.search('\d', html_level_string))
		
		html_level_string = str(html_crawler.find('li',{'id':'resources_deuterium'}))
		deuterium_available = int(re.search('\d', html_level_string))
		
		if(self.metal_upgrade_cost > metal_available && self.crystal_upgrade_cost > crystal_available && self.deuterium_upgrade_cost > deuterium_available)
				return 1
			
		return 0

class _Resource(_entity):
	
	robot_factory = 0
	nanite_factory = 0
	
	def __init__(self, browser, modifiers, base_costs, id, link, base_production, base_consumption):
		_Entity.__init__(self, browser, modifiers, base_costs, id, link)
		self.base_production = base_production
		self.base_consumption = base_consumption
		
		self.power_cost = _consumption()
		self.production = _production()

	def _buildtime(self): #Buildtime in Seconds
		return 60*60*((self.metal_upgrade_cost + self.crystal_upgrade_cost) / (2500 * max(4 - self.level / 2, 1) * (1 + (self.robot_factory)) * (2 ^ (self.nanite_factory)))))
	
	def _consumption(self):
		return self.base_consumption * ((self.level * pow(1.1, self.level)) - (self.level - 1) * pow(1.1, (self.level - 1)))
	
	def _production(self): #Production in Hours
		return self.base_production * self.level * pow(1.1, self.level)
		
	def buildable(self, browser): #Function is redefined for resource buildings to also take into consideration their energy consumption.
		self._update_costs(browser)
		
		html_crawler = BeautifulSoup(html.read())
		html_level_string = str(html_crawler.find('span',{'id':'resources_metal'}))
		metal_available = int(re.search('\d', html_level_string))
		
		html_level_string = str(html_crawler.find('span',{'id':'resources_crystal'}))
		crystal_available = int(re.search('\d', html_level_string))
		
		html_level_string = str(html_crawler.find('li',{'id':'resources_deuterium'}))
		deuterium_available = int(re.search('\d', html_level_string))
		
		html_level_string = str(html_crawler.find('li',{'id':'resources_energy'}))
		energy_available = int(re.search('\d', html_level_string))
		
		if self.metal_upgrade_cost < metal_available and self.crystal_upgrade_cost < crystal_available and self.deuterium_upgrade_cost < deuterium_available:
			if self.power_cost - 10 < energy_available:
				return 1
		return 0

class _Facility(_entity):